<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <title>数据结构-字典 - 黑白の世界</title><meta name="Description" content="完成对跳表的说明，对散列的定义，实现与应用"><meta property="og:title" content="数据结构-字典" />
<meta property="og:description" content="完成对跳表的说明，对散列的定义，实现与应用" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zzy2210.github.io/post/dict/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-11-07T22:55:36+08:00" />
<meta property="article:modified_time" content="2025-02-28T03:10:12+00:00" /><meta property="og:site_name" content="黑白の世界" />

<meta name="twitter:card" content="summary"/><meta name="twitter:title" content="数据结构-字典"/>
<meta name="twitter:description" content="完成对跳表的说明，对散列的定义，实现与应用"/>
<meta name="application-name" content="My cool site">
<meta name="apple-mobile-web-app-title" content="My cool site"><meta name="theme-color" content="#ffffff"><meta name="msapplication-TileColor" content="#da532c"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="https://zzy2210.github.io/post/dict/" /><link rel="prev" href="https://zzy2210.github.io/post/queue/" /><link rel="next" href="https://zzy2210.github.io/post/tree/" /><link rel="stylesheet" href="/css/style.min.css"><link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
        <noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css"></noscript><link rel="preload" href="https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
        <noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css"></noscript><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "数据结构-字典",
        "inLanguage": "zh-CN",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https:\/\/zzy2210.github.io\/post\/dict\/"
        },"genre": "post","keywords": "data structure","wordcount":  3047 ,
        "url": "https:\/\/zzy2210.github.io\/post\/dict\/","datePublished": "2022-11-07T22:55:36+08:00","dateModified": "2025-02-28T03:10:12+00:00","publisher": {
            "@type": "Organization",
            "name": ""},"author": {
                "@type": "Person",
                "name": "y1nhui"
            },"description": "完成对跳表的说明，对散列的定义，实现与应用"
    }
    </script></head>
    <body data-header-desktop="fixed" data-header-mobile="auto"><script type="text/javascript">(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('auto' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'auto' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="黑白の世界">黑白の世界</a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/post/"> 文章 </a><a class="menu-item" href="/tags/"> 标签 </a><a class="menu-item" href="/categories/"> 分类 </a><a class="menu-item" href="/friend/"> 友链 </a><a class="menu-item" href="/about/" title="About"> About </a><span class="menu-item delimiter"></span><a href="javascript:void(0);" class="menu-item theme-switch" title="Switch Theme">
                    <i class="fas fa-adjust fa-fw" aria-hidden="true"></i>
                </a></div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="黑白の世界">黑白の世界</a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><a class="menu-item" href="/post/" title="">文章</a><a class="menu-item" href="/tags/" title="">标签</a><a class="menu-item" href="/categories/" title="">分类</a><a class="menu-item" href="/friend/" title="">友链</a><a class="menu-item" href="/about/" title="About">About</a><a href="javascript:void(0);" class="menu-item theme-switch" title="Switch Theme">
                <i class="fas fa-adjust fa-fw" aria-hidden="true"></i>
            </a></div>
    </div>
</header><main class="main">
                <div class="container"><div class="page single special"><h1 class="single-title animate__animated animate__pulse animate__faster">数据结构-字典</h1><div class="content" id="content"><h1 id="数据结构-字典">数据结构 字典</h1>
<h2 id="前言">前言</h2>
<p>这一章的撰写有些纠结。因为我个人是根据 《数据结构、算法与应用 C++ 实现》这本书来进行学习与博客编写的。
这一章的章节名是跳表与散列，但是个人的粗略翻阅，感觉跳表并不是一个主要的点，甚至他的实现都只是个可选内容。
再考虑到平时翻阅资料似乎也很少看到跳表，更多的是哈希表，所以本文的核心内容还是放在了哈希表上面。
同时考虑到线性表、跳表、哈希表这些都是为了实现字典，所以本篇博客名为字典，而非跳表与散列之类。</p>
<h2 id="定义">定义</h2>
<h3 id="跳表">跳表</h3>
<p>在一个长为n的有序数组上通过折半查找找到某个数据，需要的时间为O(logn)，但是在有序链表上确是O(n)</p>
<p>为了优化链表上的查找，我们可以随机地创建一些新的指针来指向链表中的某些节点。这样就不需要从头遍历到尾来查询，而是直接使用某些指针来定位</p>
<p>这样的链表便叫做跳表，额外在家指针的节点，以及增加多少个额外指针都是通过随机算法来确定。</p>
<p>跳表查找、插入、删除的平均时间复杂度为O(logn)，最坏情况为O(n)</p>
<h3 id="散列表哈希表">散列表/哈希表</h3>
<p>假设数值对p的关键字为k，有一hash函数函数为f，那么理想情况下，p在hash表中的位置是f(k)。如果f(k)为nil，则说明没有记录</p>
<p>hash表可以将平均时间复杂度提快到O(1)，最快情况下为O(n)，不过如果是需要经常<strong>按序</strong>输出所有元素或者查找元素的话，跳表执行效率优于hash表</p>
<p>为什么说是理想情况呢？</p>
<p>我们按照这种定义来做个情景应用</p>
<p>假设现在有100个学生，但是他们的学生编号是<code>20220001-20229000</code>
<code>f=k-20220000</code>
那么这种情况下，关键字的范围有是<code>20220001</code>~<code>20229000</code>
f(k)的范围也是<code>1</code>~<code>9000</code></p>
<p>那我们就需要创建一个长为9000的的散列表来容纳，而且实际使用可能只有100。这是十分不明智地，而且初始化一个如此长的散列表，所需要的时间也是很高的</p>
<p>所以当关键字范围很大时，就不采用理想方式</p>
<p>非理想情况下的hash表，它的位置数量（可以理解为链表中的节点数量，数组中的长度）小于关键字的范围，hash函数会将若干个不同的关键字映射到同一个位置，即可能发生<code>f(k1)</code>=<code>f(k2)</code>=<code>f(k3)</code>=&hellip;=<code>f（kn）</code></p>
<p>这种非理想情况下，hash表的每一个位置被称为一个桶（bucket）,f(k)就是起始桶</p>
<pre><code>ps: 之所以叫起始桶而不是直接叫桶的地址之类的，是因为在开放寻址法的情况下，如果出现了冲突+溢出，实际使用的桶是要往后面寻找的，而不是算出的这个结果，所以被称为起始桶
</code></pre>
<p>这种情况下的散列函数有很多选择，最简单的就是<em>除法散列函数</em></p>
<p><code>f(k)=k%D </code>D指桶的数量</p>
<h4 id="冲突">冲突</h4>
<p>多个关键字对应的起始桶相同时，就是冲突</p>
<h4 id="溢出">溢出</h4>
<p>如果储存桶没有空间储存一个新的数对，就是溢出</p>
<p>当溢出发生时，有多种处理方法。最常见的是线性探查法，其余方法还有平法探查法，双重散列法</p>
<h4 id="均匀散列函数">均匀散列函数</h4>
<p>使用该hash函数映射到每一个桶的关键字的数量大致相等，冲突和溢出的平均数最少</p>
<h4 id="良好散列函数">良好散列函数</h4>
<p>实际应用中性能表现好的均匀散列函数</p>
<h4 id="线性探查法">线性探查法</h4>
<p>在发生溢出后，将数值对放入下一个桶中。</p>
<p>比如现在有 0-10 是十一个桶，使用hash函数为<code>f(k)=k%11</code>，每一个桶只能容纳一个键值对</p>
<p>先插入 80，40，65.则分别放入了 3，7，10 三个桶</p>
<p>接着插入24，58。 24放入桶2，没有问题，58本因放入桶3，但是桶3已有80，故向后寻址，放入桶4。</p>
<p>接着放入32，本因放入桶10，但是桶10已有65。这种情况下可以将之视为一个循环队列。桶10之后是桶0，将它放入桶0中。</p>
<p>上面的文字描述便可以很好地解释线性探查法的寻找与插入过程。</p>
<p>寻找：</p>
<pre><code>先查看起始桶中有无对应键值对，若无，则向后寻找。如果一直找回初始解桶还是不存在，或者找到了一个未溢出的桶，则说明该键值对不存在
</code></pre>
<p>插入：</p>
<pre><code>先向起始桶插入，如果起始桶溢出，则向后一个插入。如果全部都溢出，则返回错误
</code></pre>
<p>删除：</p>
<pre><code>这种情况下的删除比较麻烦。不能只把桶中对应的键值对删除就了事。还需要从删除位置的下一个桶开始，逐个检查每一个桶，来判断每一个桶中的元素是否实在起始桶，是否需要向移动一次，直到抵达一个未溢出的桶或者回到删除位置为止。
</code></pre>
<h4 id="链式散列">链式散列</h4>
<p>如果桶可以容量无数个键值对，那就不需要纠结溢出的问题了。</p>
<p>所以我们将每个桶都配置一个线性表，自然就可以了。</p>
<h4 id="负载因子">负载因子</h4>
<p>容纳的键值对数量处于桶的数量便是负载因子。</p>
<p>一般情况下负载因子越高，hash表的性能就越低，因而当负载因子达到一定程度的时候便应该启用hash扩容。</p>
<p>在Go原生的map中，当负载因子达到6.5时，便会启动扩容</p>
<p>可见<code>runtime/map.go</code>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">const</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// Maximum number of key/elem pairs a bucket can hold.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">bucketCntBits</span> <span class="p">=</span> <span class="mi">3</span>
</span></span><span class="line"><span class="cl">	<span class="nx">bucketCnt</span>     <span class="p">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="nx">bucketCntBits</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Maximum average load of a bucket that triggers growth is 6.5.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// Represent as loadFactorNum/loadFactorDen, to allow integer math.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">loadFactorNum</span> <span class="p">=</span> <span class="mi">13</span>
</span></span><span class="line"><span class="cl">	<span class="nx">loadFactorDen</span> <span class="p">=</span> <span class="mi">2</span>
</span></span><span class="line"><span class="cl"><span class="err">）</span>
</span></span></code></pre></div><h3 id="字典">字典</h3>
<p>dict与map理应没有区别，是由一组K-v 键值对组成的集合</p>
<p>多重字典：k-n*v 的一对多键值对组成的集合，当然，暂时不在我们的讨论范围内</p>
<p>定义：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Dict</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nf">Empty</span><span class="p">()</span> <span class="kt">bool</span>
</span></span><span class="line"><span class="cl">	<span class="nf">Size</span><span class="p">()</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 根据k返回v
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">Get</span><span class="p">(</span><span class="nx">key</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">(</span><span class="kd">interface</span><span class="p">{},</span> <span class="kt">bool</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 插入键值对
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">Insert</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">val</span> <span class="kd">interface</span><span class="p">{})</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 根据k删除键值对
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">Erase</span><span class="p">(</span><span class="nx">key</span> <span class="kd">interface</span><span class="p">{})</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>一般字典地Get除了通过关键字来随机地查找键值对外，还进行顺序存取，即利用迭代器按照关键字地升值顺序来逐渐查个查键值对</p>
<h2 id="实现">实现</h2>
<h3 id="hash-表">hash 表</h3>
<p>本来这里打算写一下线性表的dic实现，但是仔细想了想，线性表无非是之前的interface改成一个结构体里面两个interface，没有什么变动，就决定跳过线性表实现，直接开始写链式实现的hash</p>
<p>不过这里的hash map 是很不可靠的，比如没有扩容机制等，只能作为一个加强对链表hash理解的学习代码</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">hash</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">HashDict</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Buckets</span> <span class="p">[]</span><span class="o">*</span><span class="nx">chainNode</span>
</span></span><span class="line"><span class="cl">	<span class="nx">size</span>    <span class="kt">int</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">chainNode</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Key</span>  <span class="kd">interface</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Val</span>  <span class="kd">interface</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Next</span> <span class="o">*</span><span class="nx">chainNode</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">NewHashDict</span><span class="p">()</span> <span class="o">*</span><span class="nx">HashDict</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">HashDict</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">Buckets</span><span class="p">:</span> <span class="nb">make</span><span class="p">([]</span><span class="o">*</span><span class="nx">chainNode</span><span class="p">,</span> <span class="mi">11</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">d</span> <span class="o">*</span><span class="nx">HashDict</span><span class="p">)</span> <span class="nf">Empty</span><span class="p">()</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">d</span><span class="p">.</span><span class="nx">size</span> <span class="o">==</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">d</span> <span class="o">*</span><span class="nx">HashDict</span><span class="p">)</span> <span class="nf">Size</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">d</span><span class="p">.</span><span class="nx">size</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 这里使用hash函数为f(k)=k%11
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">d</span> <span class="o">*</span><span class="nx">HashDict</span><span class="p">)</span> <span class="nf">Get</span><span class="p">(</span><span class="nx">key</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">(</span><span class="kd">interface</span><span class="p">{},</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">bucket</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl">	<span class="k">switch</span> <span class="nx">key</span><span class="p">.(</span><span class="kd">type</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">case</span> <span class="kt">int</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="nx">bucket</span> <span class="p">=</span> <span class="nx">key</span><span class="p">.(</span><span class="kt">int</span><span class="p">)</span> <span class="o">%</span> <span class="mi">11</span>
</span></span><span class="line"><span class="cl">	<span class="k">case</span> <span class="kt">string</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="kd">var</span> <span class="nx">ascii</span> <span class="kt">rune</span>
</span></span><span class="line"><span class="cl">		<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">key</span><span class="p">.(</span><span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">ascii</span> <span class="o">+=</span> <span class="nx">v</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nx">bucket</span> <span class="p">=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">ascii</span><span class="p">)</span> <span class="o">%</span> <span class="mi">11</span>
</span></span><span class="line"><span class="cl">	<span class="k">default</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 个人能力有限，仅提供对string与int类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">node</span> <span class="o">:=</span> <span class="nx">d</span><span class="p">.</span><span class="nx">Buckets</span><span class="p">[</span><span class="nx">bucket</span><span class="p">];</span> <span class="nx">node</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">;</span> <span class="nx">node</span> <span class="p">=</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Next</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Key</span> <span class="o">==</span> <span class="nx">key</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Val</span><span class="p">,</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">d</span> <span class="o">*</span><span class="nx">HashDict</span><span class="p">)</span> <span class="nf">Insert</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">val</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">bucket</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl">	<span class="k">switch</span> <span class="nx">key</span><span class="p">.(</span><span class="kd">type</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">case</span> <span class="kt">int</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="nx">bucket</span> <span class="p">=</span> <span class="nx">key</span><span class="p">.(</span><span class="kt">int</span><span class="p">)</span> <span class="o">%</span> <span class="mi">11</span>
</span></span><span class="line"><span class="cl">	<span class="k">case</span> <span class="kt">string</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="kd">var</span> <span class="nx">ascii</span> <span class="kt">rune</span>
</span></span><span class="line"><span class="cl">		<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">key</span><span class="p">.(</span><span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">ascii</span> <span class="o">+=</span> <span class="nx">v</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nx">bucket</span> <span class="p">=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">ascii</span><span class="p">)</span> <span class="o">%</span> <span class="mi">11</span>
</span></span><span class="line"><span class="cl">	<span class="k">default</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 个人能力有限，仅提供对string与int类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">return</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">d</span><span class="p">.</span><span class="nx">Buckets</span><span class="p">[</span><span class="nx">bucket</span><span class="p">]</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">d</span><span class="p">.</span><span class="nx">Buckets</span><span class="p">[</span><span class="nx">bucket</span><span class="p">]</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">chainNode</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">Key</span><span class="p">:</span> <span class="nx">key</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">			<span class="nx">Val</span><span class="p">:</span> <span class="nx">val</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nx">d</span><span class="p">.</span><span class="nx">size</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">node</span> <span class="o">:=</span> <span class="nx">d</span><span class="p">.</span><span class="nx">Buckets</span><span class="p">[</span><span class="nx">bucket</span><span class="p">];</span> <span class="nx">node</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">;</span> <span class="nx">node</span> <span class="p">=</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Next</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Key</span> <span class="o">==</span> <span class="nx">key</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">node</span><span class="p">.</span><span class="nx">Val</span> <span class="p">=</span> <span class="nx">val</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Next</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">node</span><span class="p">.</span><span class="nx">Next</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">chainNode</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nx">Key</span><span class="p">:</span> <span class="nx">key</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">				<span class="nx">Val</span><span class="p">:</span> <span class="nx">val</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="nx">d</span><span class="p">.</span><span class="nx">size</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">d</span> <span class="o">*</span><span class="nx">HashDict</span><span class="p">)</span> <span class="nf">Erase</span><span class="p">(</span><span class="nx">key</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">bucket</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl">	<span class="k">switch</span> <span class="nx">key</span><span class="p">.(</span><span class="kd">type</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">case</span> <span class="kt">int</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="nx">bucket</span> <span class="p">=</span> <span class="nx">key</span><span class="p">.(</span><span class="kt">int</span><span class="p">)</span> <span class="o">%</span> <span class="mi">11</span>
</span></span><span class="line"><span class="cl">	<span class="k">case</span> <span class="kt">string</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="kd">var</span> <span class="nx">ascii</span> <span class="kt">rune</span>
</span></span><span class="line"><span class="cl">		<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">key</span><span class="p">.(</span><span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">ascii</span> <span class="o">+=</span> <span class="nx">v</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nx">bucket</span> <span class="p">=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">ascii</span><span class="p">)</span> <span class="o">%</span> <span class="mi">11</span>
</span></span><span class="line"><span class="cl">	<span class="k">default</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 个人能力有限，仅提供对string与int类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">return</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">d</span><span class="p">.</span><span class="nx">Buckets</span><span class="p">[</span><span class="nx">bucket</span><span class="p">]</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">d</span><span class="p">.</span><span class="nx">Buckets</span><span class="p">[</span><span class="nx">bucket</span><span class="p">].</span><span class="nx">Key</span> <span class="o">==</span> <span class="nx">key</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">d</span><span class="p">.</span><span class="nx">Buckets</span><span class="p">[</span><span class="nx">bucket</span><span class="p">]</span> <span class="p">=</span> <span class="nx">d</span><span class="p">.</span><span class="nx">Buckets</span><span class="p">[</span><span class="nx">bucket</span><span class="p">].</span><span class="nx">Next</span>
</span></span><span class="line"><span class="cl">		<span class="nx">d</span><span class="p">.</span><span class="nx">size</span><span class="o">--</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">node</span> <span class="o">:=</span> <span class="nx">d</span><span class="p">.</span><span class="nx">Buckets</span><span class="p">[</span><span class="nx">bucket</span><span class="p">];</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Next</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">;</span> <span class="nx">node</span> <span class="p">=</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Next</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Next</span><span class="p">.</span><span class="nx">Key</span> <span class="o">==</span> <span class="nx">key</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">node</span><span class="p">.</span><span class="nx">Next</span> <span class="p">=</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Next</span><span class="p">.</span><span class="nx">Next</span>
</span></span><span class="line"><span class="cl">			<span class="nx">d</span><span class="p">.</span><span class="nx">size</span><span class="o">--</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="应用">应用</h2>
<p>字典（hash实现）的优点就再与基于关键字存取。</p>
<p>本系列开篇文章说过，我个人是因为某次优化突然脑子转不过来了，于是打算回顾一下相关知识，重开了博客</p>
<p>这里就假设一个大概相似的情景</p>
<p>现在从外界传入了一串字符串，我们需要将之与黑名单对比，并且删去黑名单内字符，输出余下的内容</p>
<p>看上去很简单吧</p>
<p>我当时脑子一抽，写出了第一个版本</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">demo</span><span class="p">(</span><span class="nx">val</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="p">[]</span><span class="kt">string</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">black</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;a&#34;</span><span class="p">,</span> <span class="s">&#34;b&#34;</span><span class="p">,</span> <span class="s">&#34;c&#34;</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">b</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">val</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">black</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="nx">v</span> <span class="o">==</span> <span class="nx">b</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nx">val</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">val</span><span class="p">[:</span><span class="nx">i</span><span class="p">],</span> <span class="nx">val</span><span class="p">[</span><span class="nx">i</span><span class="p">:]</span><span class="o">...</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">val</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>先不论代码是否有点问题，单是这两个for循环一套，直接来了个O(n^2)，就应该感到了深深的难受</p>
<p>那怎么办呢， 用 就用字典（map）吧</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">demo2</span><span class="p">(</span><span class="nx">val</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="p">[]</span><span class="kt">string</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">black</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;a&#34;</span><span class="p">,</span> <span class="s">&#34;b&#34;</span><span class="p">,</span> <span class="s">&#34;c&#34;</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">dict</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">bool</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">val</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">dict</span><span class="p">[</span><span class="nx">v</span><span class="p">]</span> <span class="p">=</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">black</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">_</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">dict</span><span class="p">[</span><span class="nx">v</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">ok</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">dict</span><span class="p">[</span><span class="nx">v</span><span class="p">]</span> <span class="p">=</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">result</span> <span class="p">[]</span><span class="kt">string</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">dict</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">v</span> <span class="o">==</span> <span class="kc">true</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">result</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span> <span class="nx">k</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">result</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>明显可见，没有O(n^2)现象</p>
<h2 id="总结">总结</h2>
<p>这篇文章，写的有点急了。最后在写应用的时候，有点迷茫不知道该怎么说应用了。leetcode上面看了看hash标签的题目，好像也不是很好体现</p>
<p>最后干脆心一横，拿之前脑抽的事情，大概描述一下写出来了。</p></div><div id="comments"><div id="giscus" class="comment"></div><noscript>
                Please enable JavaScript to view the comments powered by <a href="https://giscus.app">Giscus</a>.
            </noscript></div></div></div>
            </main><footer class="footer">
        <div class="footer-container"><div class="footer-line">Powered by <a href="https://gohugo.io/" target="_blank" rel="noopener noreffer" title="Hugo 0.123.8">Hugo</a> | Theme - <a href="https://github.com/dillonzq/LoveIt" target="_blank" rel="noopener noreffer" title="LoveIt 0.2.11"><i class="far fa-kiss-wink-heart fa-fw" aria-hidden="true"></i> LoveIt</a>
                </div><div class="footer-line" itemscope itemtype="http://schema.org/CreativeWork"><i class="far fa-copyright fa-fw" aria-hidden="true"></i><span itemprop="copyrightYear">2022 - 2025</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="https://github.com/zzy2210" target="_blank">y1nhui</a></span><span class="icp-splitter">&nbsp;|&nbsp;</span><br class="icp-br"/>
                    <span class="icp">皖ICP备19008609号-1</span></div>
        </div>
    </footer></div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="Back to Top">
                <i class="fas fa-arrow-up fa-fw" aria-hidden="true"></i>
            </a><a href="#" id="view-comments" class="fixed-button" title="View Comments">
                <i class="fas fa-comment fa-fw" aria-hidden="true"></i>
            </a>
        </div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/clipboard@2.0.11/dist/clipboard.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/sharer.js@0.5.1/sharer.min.js"></script><script type="text/javascript">window.config={"code":{"copyTitle":"Copy to clipboard","maxShownLines":50},"comment":{"giscus":{"category":"Announcements","categoryId":"DIC_kwDOIVCTEM4CdyQM","darkTheme":"dark","emitMetadata":"0","inputPosition":"bottom","lang":"zh-CN","lazyLoading":false,"lightTheme":"light","mapping":"pathname","reactionsEnabled":"1","repo":"zzy2210/zzy2210.github.io","repoId":"R_kgDOIVCTEA"}}};</script><script type="text/javascript" src="/js/theme.min.js"></script></body>
</html>
